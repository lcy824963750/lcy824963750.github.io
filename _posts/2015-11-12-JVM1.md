---
layout: post
title: '《深入JVM》之Java的体系结构'
date: '2015-11-12'
header-img: "img/post-bg-web.jpg"
tags:
     - JVM
author: 'lcy'
---

&emsp;&emsp;近来阅读《深入java虚拟机》,便把书中的一些知识整理成笔记发表到博客上，和大家一同学习。
<h3>Java的体系结构</h3>
&emsp;&emsp;Java体系结构包括四个部分：
&emsp;&emsp;1、Java程序设计语言
&emsp;&emsp;2、Java class 文件格式
&emsp;&emsp;3、Java应用编程接口(Java API)
&emsp;&emsp;4、Java虚拟机

&emsp;&emsp;我们使用Java程序设计语言编写源代码（.Java文件），Java编译器将其编译为class文件，然后再JVM中运行class文件，在程序运行过程中，JVM通过调用class文件中实现了Java API的方法来满足程序的Java API调用。
&emsp;&emsp;JVM和Java API构成Java的运行时环境。

<h4>一、Java虚拟机</h4>
&emsp;&emsp;JVM的主要任务就是装载class文件并且执行其中的字节码。JVM中包含一个类装载器，它可以从程序和API中装载class文件，Java API中只有程序执行需要的那些类才会被装载。字节码由JVM的执行引擎来执行。

&emsp;&emsp;不同的JVM中，执行引擎可能实现的非常不同。(常见方式四种)
&emsp;&emsp; 1. 最简单的一种，一次性解释字节码。
&emsp;&emsp; 2. 第二种叫做即时编译器，第一次被执行的字节码会被编译成本地机器代码，编译出的本地机器代码会被缓存，方法以后被调用时会被重用。这种方式的缺点是消耗内存。
&emsp;&emsp; 3. 第三种叫做自适应优化器，虚拟机开始的时候解释字节码，但是会监视运行中程序的活动，并且记录下使用最频繁的代码段，程序运行时，虚拟机只把那些活动最频繁的代码编译成本地代码，其他的代码因为使用的并不频繁，继续保留为字节码。
&emsp;&emsp; 4. 最后一种由硬件芯片构成，它用本地方法执行字节码。

&emsp;&emsp;Java方法的分类：Java方法和本地方法(JNI)。

&emsp;&emsp;Java方法：Java方法由Java语言编写，编译成字节码，存储在class文件中。
&emsp;&emsp;本地方法(JNI)：它是由其他语言编写(C、C++、汇编)，编译成和处理器相关的机器代码，本地方法保存在动态连接库中，格式为各个平台所特有。Java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库。本地方法是连接Java程序和底层主机操作系统的。

<h4>二、类装载器的体系结构</h4>
&emsp;&emsp;JVM中实际存在着多个类装载器，JVM有着灵活的类装载器结构。

&emsp;&emsp;一个Java应用程序可以使用两种类装载器，启动类装载器和用户定义的类装载器。
&emsp;&emsp;启动类装载器：是JVM的一部分，通常采用某种默认方式从本地磁盘装载类，包括Java API的类。
&emsp;&emsp;用户定义类装载器：能够使用自定义的方式来装载类，用户自定义的类装载器能够使用Java语言编写，能够被编译为class文件，能够被虚拟机装载，还能够向其他对象一样被实例化。他们实际上只是运行的Java应用程序中的一部分。

&emsp;&emsp;用户自定义装载器使得在运行时扩展Java程序成为可能。

&emsp;&emsp;注意的地方：每一个类被装载的时候，JVM都监视这个类，看它是被启动类装载器装载还是被用户定义装载器装载，当被装载的类引用了另外一个类时，JVM会使用装载第一个类的装载器来装载这个类。
&emsp;&emsp;因为JVM使用这种方式来装载类，所以被装载的类默认情况下只能看到被同一个类装载器装载的别的类。通过这种方法，Java的体系结构允许在一个应用程序中建立多个命名空间，运行时的Java程序中每一个类装载器都有自己的命名空间。
&emsp;&emsp;通过把不同来源的代码用不同的类装载器装载，就可以使他们位于不同的命名空间中，这样就可以防止不同来源的class文件之间的互相访问。

<h4>三、Java class文件</h4>

&emsp;&emsp;Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。

&emsp;&emsp;Java class文件对平台无关性的支持？
&emsp;&emsp;1.编译和连接C++程序获得的二进制可执行文件只能在特定的硬件平台和操作系统上完成，因为这个二进制文件包含了目标处理器的机器语言。而Java编译器把Java源文件编译成为二进制字节码，这种字节码就是JVM的机器语言。
&emsp;&emsp;2.在传统的二进制可执行文件中，支持不同处理器的二进制可执行文件的整数字节顺序可能是不同的，而Java class文件一向是高位在前，不管支持何种处理器。

&emsp;&emsp;Java class文件对网络移动性的支持？
&emsp;&emsp;1.class文件设计的非常紧凑，它可以快速的在网络上传送。
&emsp;&emsp;2.因为Java程序是动态连接和扩展的，可以在需要的时候才能网络上下载。

<h4>四、Java API</h4>
&emsp;&emsp;Java程序自身之所以能够成为具有平台无关性的程序，就是因为在每个特定的主机平台上都明确的实现了JVM和Java API。Java API为了访问主机的资源，调用了本地方法，所以Java程序就不需要再调用本地方法，而仅仅需要调用Java API。

&emsp;&emsp;安全性：Java API进行任何有危险的操作时，都会通过查询安全管理器来确认是否得到了授权。

<h4>五、Java程序设计语言</h4>
&emsp;&emsp;Java语言的特点？
&emsp;&emsp;1.Java是一门面向对象的语言，可以提高代码的重用率。
&emsp;&emsp;2.Java可以提高开发者的效率，但是执行速度较慢。
&emsp;&emsp;3.不可以通过指针运算直接访问内存，Java使用对象时，必须严格的遵守类型规则。（保护内存）
&emsp;&emsp;4.使用GC自动回收不再被使用的对象，不用像C++那样手动释放不再使用对象的内存。（保护内存）
&emsp;&emsp;5.提供了数组边界检查。（保护内存）
&emsp;&emsp;6.每次使用一个引用时，必须确认这个引用不为null，否则抛出一个空指针异常。（健壮性）

<h3>Java体系结构付出的代价</h3>
&emsp;&emsp;1.Java程序的执行速度较低，虽然随着自适应优化等技术的出现，Java程序能够以和本地编译的C程序媲美的速度进行，但是这往往是针对于特定的虚拟机，很难保证在多个虚拟机上都能取得令人满意的性能。
&emsp;&emsp;2.内存管理和线程管理上的缺陷，即不确定性。无法确定GC是否开始回收，无法确认回收会持续多长时间，JVM讨论线程调度时也非常笼统。
&emsp;&emsp;3.为了实现平台无关性，也要付出代价，即最小公分母问题。尽管各个操作系统都有共性，但是每个操作系统都有个性，想要给程序提供访问任何操作系统的系统服务功能的API，就不得不决定支持哪一种特性。
&emsp;&emsp;4.动态连接的Java程序中，class文件极易被逆向编译。

> 如有任何知识产权、版权问题或理论错误，还请指正。
>
> 转载请注明原作者及以上信息。
